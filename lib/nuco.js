// Generated by CoffeeScript 1.6.3
var cluster, exec, exports, fs, nuco, os, path, seek, util;

os = require('os');

fs = require('fs');

path = require('path');

util = require('util');

exec = require('child_process').exec;

cluster = require('cluster');

seek = function(dir, type, only, save) {
  var f, res, _i, _len, _ref;
  if (type == null) {
    type = 'd';
  }
  if (only == null) {
    only = /.*/;
  }
  if (save == null) {
    save = /^(\.|node_modules|public)/;
  }
  res = [];
  _ref = fs.readdirSync(dir);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    f = _ref[_i];
    if (save.test(f)) {
      continue;
    }
    f = path.resolve(dir, f);
    switch (type) {
      case 'f':
        if ((fs.statSync(f)).isDirectory()) {
          res = res.concat(seek(f, type, only, save));
        } else {
          if (only.test(f)) {
            res.push(f);
          }
        }
        break;
      case 'd':
        if ((fs.statSync(f)).isDirectory()) {
          if (only.test(f)) {
            res.push(f);
          }
          res = res.concat(seek(f, type, only, save));
        }
    }
  }
  return res;
};

nuco = function(main, options) {
  var bin, compile, dir, dstpath, file, find, i, message, method, save, srcpath, stderr, stdout, workers, _base, _base1, _fn, _fn1, _fn2, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref, _ref1, _ref2, _ref3, _ref4;
  if (options == null) {
    options = {};
  }
  options.bar || (options.bar = false);
  options.env || (options.env = 'development');
  options.port || (options.port = 3000);
  options.forks || (options.forks = 'auto');
  options.color || (options.color = false);
  options.watch || (options.watch = false);
  options.asset || (options.asset = null);
  (_base = process.env).PORT || (_base.PORT = options.port);
  (_base1 = process.env).NODE_ENV || (_base1.NODE_ENV = options.envs);
  if (options.bar) {
    stdout = process.stdout.write;
    stderr = process.stderr.write;
    message = function() {
      var head, i, msg, now, _i, _ref;
      msg = process.env.__nucoenv === 'master' ? '\x1b[35m' : '\x1b[36m';
      now = new Date();
      now = "" + (('00' + now.getHours()).slice(-2)) + ":" + (('00' + now.getMinutes()).slice(-2)) + ":" + (('00' + now.getSeconds()).slice(-2));
      msg += head = now + ' ' + process.env.__nucoenv;
      for (i = _i = 0, _ref = 20 - head.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        msg += ' ';
      }
      return msg;
    };
    process.stdout.write = function() {
      if (80 === arguments.callee.caller.toString().length) {
        arguments[0] = "" + (message()) + "| \x1b[0m" + arguments[0];
      } else {
        arguments[0] = "" + (message()) + "|  \x1b[0m" + arguments[0];
      }
      return stdout.apply(this, arguments);
    };
    process.stderr.write = function() {
      arguments[0] = "" + (message()) + "\x1b[0m| " + arguments[0];
      return stderr.apply(this, arguments);
    };
  }
  if (options.color) {
    _ref = ['log', 'info', 'warn', 'error'];
    _fn = function(method) {
      var origin;
      origin = console[method];
      return console[method] = function() {
        var args, data;
        data = (function() {
          switch (method) {
            case 'log':
              return '\x1b[32m';
            case 'info':
              return '\x1b[34m';
            case 'warn':
              return '\x1b[33m';
            case 'error':
              return '\x1b[31m';
            default:
              return '\x1b[0m';
          }
        })();
        args = Array.prototype.slice.call(arguments);
        args.unshift(data);
        args.push('\x1b[0m');
        return origin.apply(this, args);
      };
    };
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      method = _ref[_i];
      _fn(method);
    }
  }
  if (cluster.isMaster) {
    process.env.__nucoenv = 'master';
    cluster.on('online', function(worker) {
      return console.log('worker online');
    });
    cluster.on('listening', function(worker) {
      return console.log("worker listening on port " + process.env.PORT);
    });
    cluster.on('exit', function(worker) {
      var i, _j, _len1, _results;
      console.warn('worker exit');
      _results = [];
      for (i = _j = 0, _len1 = workers.length; _j < _len1; i = ++_j) {
        worker = workers[i];
        if (!worker) {
          _results.push(workers[i] = cluster.fork({
            __nucoenv: "worker." + (i + 1)
          }).process.pid);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
    options.forks = parseInt(options.forks);
    if (!options.forks) {
      options.forks = os.cpus().length;
    }
    workers = Array(options.forks);
    for (i = _j = 0, _ref1 = options.forks; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      workers[i] = cluster.fork({
        __nucoenv: "worker." + (i + 1)
      }).process.pid;
    }
    if (options.watch) {
      process.on('nuco::restart', function() {
        var worker, _k, _len1, _results;
        _results = [];
        for (i = _k = 0, _len1 = workers.length; _k < _len1; i = ++_k) {
          worker = workers[i];
          if (!(worker)) {
            continue;
          }
          delete workers[i];
          _results.push(process.kill(worker));
        }
        return _results;
      });
      save = /^(\.|node_modules|public)/;
      if (options.asset) {
        save = new RegExp("^(\\.|node_modules|" + options.asset + "|public)");
      }
      _ref2 = seek('.', 'd', /.*/, save);
      _fn1 = function(dir) {
        return fs.watch(dir, function(act, file) {
          if (/\.(js|coffee)$/.test(file)) {
            console.info(act, file);
            return process.emit('nuco::restart');
          }
        });
      };
      for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
        dir = _ref2[_k];
        _fn1(dir);
      }
    }
    if (options.asset) {
      srcpath = path.resolve(options.asset);
      dstpath = path.resolve('public');
      find = function(name) {
        var file;
        file = "./node_modules/.bin/" + name;
        if (fs.existsSync(file)) {
          return file;
        }
        file = "./node_modules/nuco/node_modules/.bin/" + name;
        if (fs.existsSync(file)) {
          return file;
        }
        file = "../.bin/" + name;
        if (fs.existsSync(file)) {
          return file;
        }
        return name;
      };
      bin = {
        coffee: find('coffee'),
        stylus: find('stylus'),
        uglify: find('uglifyjs'),
        sqwish: find('sqwish')
      };
      compile = function(src) {
        var dst, ini;
        ini = new Date;
        dst = src.replace(srcpath, dstpath);
        if (!fs.existsSync(src)) {
          return fs.unlinkSync(dst);
        }
        if (/^\./.test(src)) {
          return;
        }
        if (/\.js$/.test(src)) {
          fs.createReadStream(src).pipe(fs.createWriteStream(dst));
          exec("echo `" + bin.uglify + " < " + dst + "` > " + dst, function() {
            return console.info('compiled', "(" + (new Date - ini) + " ms)", src.replace("" + srcpath + "/", ''));
          });
        }
        if (/\.coffee$/.test(src)) {
          dst = dst.replace(/\.coffee$/, '.js');
          exec("" + bin.coffee + " -p " + src + " > " + dst, function(err, stdout, stderr) {
            if (stderr) {
              console.warn(stderr);
            }
            return exec("echo `" + bin.uglify + " < " + dst + "` > " + dst, function() {
              return console.info('compiled', "(" + (new Date - ini) + " ms)", src.replace("" + srcpath + "/", ''));
            });
          });
        }
        if (/\.css$/.test(src)) {
          fs.createReadStream(src).pipe(fs.createWriteStream(dst));
          exec("" + bin.sqwish + " " + dst + " -o " + dst, function() {
            return console.info('compiled', "(" + (new Date - ini) + " ms)", src.replace("" + srcpath + "/", ''));
          });
        }
        if (/\.styl$/.test(src)) {
          dst = dst.replace(/\.styl$/, '.css');
          return exec("" + bin.stylus + " -c -U -I node_modules < " + src + " > " + dst, function(err, stdout, stderr) {
            if (stderr) {
              console.warn(stderr);
            }
            return exec("" + bin.sqwish + " " + dst + " -o " + dst, function() {
              return console.info('compiled', "(" + (new Date - ini) + " ms)", src.replace("" + srcpath + "/", ''));
            });
          });
        }
      };
      _ref3 = seek(options.asset, 'f', /\.(js|coffee|css|styl)$/);
      for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {
        file = _ref3[_l];
        compile(file);
      }
      _ref4 = seek('.', 'd', new RegExp(options.asset));
      _fn2 = function(dir) {
        return fs.watch(dir, function(act, file) {
          if (/\.(js|coffee|css|styl)$/.test(file)) {
            return compile(path.resolve(dir, file));
          }
        });
      };
      for (_m = 0, _len3 = _ref4.length; _m < _len3; _m++) {
        dir = _ref4[_m];
        _fn2(dir);
      }
    }
    return;
  }
  return require(path.resolve(main));
};

nuco.isnuco = nuco.isNuco = function() {
  return process.env.__nucoenv != null;
};

module.exports = exports = nuco;
